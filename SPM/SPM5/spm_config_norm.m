function opts = spm_config_norm
% Configuration file for normalise jobs
%_______________________________________________________________________
% Copyright (C) 2005 Wellcome Department of Imaging Neuroscience

% John Ashburner
% $Id: spm_config_norm.m 1032 2007-12-20 14:45:55Z john $


%_______________________________________________________________________
 

smosrc.type = 'entry';
smosrc.name = 'Source Image Smoothing';
smosrc.tag  = 'smosrc';
smosrc.strtype = 'e';
smosrc.num  = [1 1];
smosrc.def  = 'normalise.estimate.smosrc';
smosrc.help = {[...
'Smoothing to apply to a copy of the source image. ',...
'The template and source images should have approximately ',...
'the same smoothness. Remember that the templates supplied ',...
'with SPM have been smoothed by 8mm, and that smoothnesses ',...
'combine by Pythagoras'' rule.']};

%------------------------------------------------------------------------

smoref.type = 'entry';
smoref.name = 'Template Image Smoothing';
smoref.tag  = 'smoref';
smoref.strtype = 'e';
smoref.num  = [1 1];
smoref.def  = 'normalise.estimate.smoref';
smoref.help = {[...
'Smoothing to apply to a copy of the template image. ',...
'The template and source images should have approximately ',...
'the same smoothness. Remember that the templates supplied ',...
'with SPM have been smoothed by 8mm, and that smoothnesses ',...
'combine by Pythagoras'' rule.']};

%------------------------------------------------------------------------
 
regtype.type = 'menu';
regtype.name = 'Affine Regularisation';
regtype.tag  = 'regtype';
regtype.labels = {'ICBM space template', 'Average sized template','No regularisation'};
regtype.values = {'mni','subj','none'};
regtype.def  = 'normalise.estimate.regtype';
regtype.help   = {[...
'Affine registration into a standard space can be made more robust by ',...
'regularisation (penalising excessive stretching or shrinking).  The ',...
'best solutions can be obtained by knowing the approximate amount of ',...
'stretching that is needed (e.g. ICBM templates are slightly bigger ',...
'than typical brains, so greater zooms are likely to be needed). ',...
'If registering to an image in ICBM/MNI space, then choose the first ',...
'option.  If registering to a template that is close in size, then ',...
'select the second option.  If you do not want to regularise, then ',...
'choose the third.']};
 
%------------------------------------------------------------------------

template.type = 'files';
template.name = 'Template Image';
template.tag  = 'template';
template.filter = 'image';
template.num  = [1 Inf];
template.help   = {[...
'Specify a template image to match the source image with. ',...
'The contrast in the template must be similar to that of the ',...
'source image in order to achieve a good registration.  It is ',...
'also possible to select more than one template, in which case ',...
'the registration algorithm will try to find the best linear ',...
'combination of these images in order to best model the intensities ',...
'in the source image.']};
%------------------------------------------------------------------------

weight.type = 'files';
weight.name = 'Template Weighting Image';
weight.tag  = 'weight';
weight.filter = 'image';
weight.num  = [0 1];
weight.def  = 'normalise.estimate.weight';
p1 = [...
'Applies a weighting mask to the template(s) during the parameter ',...
'estimation.  With the default brain mask, weights in and around the ',...
'brain have values of one whereas those clearly outside the brain are ',...
'zero.  This is an attempt to base the normalisation purely upon ',...
'the shape of the brain, rather than the shape of the head (since ',...
'low frequency basis functions can not really cope with variations ',...
'in skull thickness).'];
p2 = [...
'The option is now available for a user specified weighting image. ',...
'This should have the same dimensions and mat file as the template ',...
'images, with values in the range of zero to one.'];
weight.help = {p1,'',p2};
 
%------------------------------------------------------------------------

cutoff.type = 'entry';
cutoff.name = 'Nonlinear Frequency Cutoff';
cutoff.tag  = 'cutoff';
cutoff.strtype = 'e';
cutoff.num  = [1 1];
cutoff.def  = 'normalise.estimate.cutoff';
cutoff.help = {[...
'Cutoff of DCT bases.  Only DCT bases of periods longer than the ',...
'cutoff are used to describe the warps. The number used will ',...
'depend on the cutoff and the field of view of the template image(s).']};

%------------------------------------------------------------------------

nits.type = 'entry';
nits.name = 'Nonlinear Iterations';
nits.tag  = 'nits';
nits.strtype = 'w';
nits.num  = [1 1];
nits.def  = 'normalise.estimate.nits';
nits.help = {'Number of iterations of nonlinear warping performed.'};

%------------------------------------------------------------------------

reg.type = 'entry';
reg.name = 'Nonlinear Regularisation';
reg.tag  = 'reg';
reg.strtype = 'e';
reg.num  = [1 1];
reg.def  = 'normalise.estimate.reg';
reg.help = {[...
'The amount of regularisation for the nonlinear part of the spatial ',...
'normalisation. ',...
'Pick a value around one.  However, if your normalised images appear ',...
'distorted, then it may be an idea to increase the amount of ',...
'regularisation (by an order of magnitude) - or even just use an affine ',...
'normalisation. ',...
'The regularisation influences the smoothness of the deformation ',...
'fields.']};

%------------------------------------------------------------------------

wtsrc.type = 'files';
wtsrc.name = 'Source Weighting Image';
wtsrc.tag  = 'wtsrc';
wtsrc.filter = 'image';
wtsrc.num  = [0 1];
wtsrc.val  = {{}};
wtsrc.help = {[...
'Optional weighting images (consisting of pixel ',...
'values between the range of zero to one) to be used for registering ',...
'abnormal or lesioned brains.  These images should match the dimensions ',...
'of the image from which the parameters are estimated, and should contain ',...
'zeros corresponding to regions of abnormal tissue.']};

%------------------------------------------------------------------------

eoptions.type = 'branch';
eoptions.name = 'Estimation Options';
eoptions.tag  = 'eoptions';
eoptions.val  = {template,weight,smosrc,smoref,regtype,cutoff,nits,reg};
eoptions.help = {'Various settings for estimating warps.'};

%------------------------------------------------------------------------

preserve.type = 'menu';
preserve.name = 'Preserve';
preserve.tag  = 'preserve';
preserve.labels = {'Preserve Concentrations','Preserve Amount'};
preserve.values = {0,1};
preserve.def  = 'normalise.write.preserve';
p1 = ['Preserve Concentrations: ',...
'Spatially normalised images are not "modulated". The warped images ',...
'preserve the intensities of the original images.'];
p2 = ['Preserve Total: ',...
'Spatially normalised images are "modulated" in order to preserve the ',...
'total amount of signal in the images. Areas that are expanded during ',...
'warping are correspondingly reduced in intensity.'];
preserve.help = {p1,'',p2};

%------------------------------------------------------------------------

bb.type = 'entry';
bb.name = 'Bounding box';
bb.tag  = 'bb';
bb.num  = [2 3];
bb.strtype = 'e';
bb.def = 'normalise.write.bb';
bb.help = {[...
'The bounding box (in mm) of the volume which is to be written ',...
'(relative to the anterior commissure).']};

%------------------------------------------------------------------------

vox.type = 'entry';
vox.name = 'Voxel sizes';
vox.tag  = 'vox';
vox.num  = [1 3];
vox.strtype = 'e';
vox.def  = 'normalise.write.vox';
vox.help = {'The voxel sizes (x, y & z, in mm) of the written normalised images.'};

%------------------------------------------------------------------------

interp.type = 'menu';
interp.name = 'Interpolation';
interp.tag  = 'interp';
interp.labels = {'Nearest neighbour','Trilinear','2nd Degree B-spline',...
'3rd Degree B-Spline ','4th Degree B-Spline ','5th Degree B-Spline',...
'6th Degree B-Spline','7th Degree B-Spline'};
interp.values = {0,1,2,3,4,5,6,7};
interp.def  = 'normalise.write.interp';
interp.help = {...
['The method by which the images are sampled when being written in a ',...
'different space.'],...
['    Nearest Neighbour: ',...
'    - Fastest, but not normally recommended.'],...
['    Bilinear Interpolation: ',...
'    - OK for PET, or realigned fMRI.'],...
['    B-spline Interpolation: ',...
'    - Better quality (but slower) interpolation/* \cite{thevenaz00a}*/, especially ',...
'      with higher degree splines.  Do not use B-splines when ',...
'      there is any region of NaN or Inf in the images. '],...
};

%------------------------------------------------------------------------

wrap.type = 'menu';
wrap.name = 'Wrapping';
wrap.tag  = 'wrap';
wrap.labels = {'No wrap','Wrap X','Wrap Y','Wrap X & Y','Wrap Z',...
'Wrap X & Z','Wrap Y & Z','Wrap X, Y & Z'};
wrap.values = {[0 0 0],[1 0 0],[0 1 0],[1 1 0],[0 0 1],[1 0 1],[0 1 1],[1 1 1]};
wrap.def    = 'normalise.write.wrap';
wrap.help = {...
'These are typically:',...
['    No wrapping: for PET or images that have already ',...
'                  been spatially transformed. '],...
['    Wrap in  Y: for (un-resliced) MRI where phase encoding ',...
'                  is in the Y direction (voxel space).']};

%------------------------------------------------------------------------

roptions.type = 'branch';
roptions.name = 'Writing Options';
roptions.tag  = 'roptions';
roptions.val  = {preserve,bb,vox,interp,wrap};
roptions.help = {'Various options for writing normalised images.'};

%------------------------------------------------------------------------

source.type = 'files';
source.name = 'Source Image';
source.tag  = 'source';
source.num  = [1 1];
source.filter = 'image';
source.help   = {[...
'The image that is warped to match the template(s).  The result is ',...
'a set of warps, which can be applied to this image, or any other ',...
'image that is in register with it.']};

scansr.type = 'files';
scansr.name = 'Images to Write';
scansr.tag  = 'resample';
scansr.num  = [1 Inf];
scansr.filter = 'image';
scansr.help   = {[...
'These are the images for warping according to the estimated parameters. ',...
'They can be any images that are in register with the "source" image used ',...
'to generate the parameters.']};

matname.type = 'files';
matname.name = 'Parameter File';
matname.tag  = 'matname';
matname.num  = [1 1];
matname.filter  = 'mat';
matname.ufilter = '.*_sn\.mat$';
matname.help = {[...
'Select the ''_sn.mat'' file containing the spatial normalisation ',...
'parameters for that subject.']};

%------------------------------------------------------------------------

subj.type = 'branch';
subj.name = 'Subject';
subj.tag  = 'subj';
subj.val  = {source, wtsrc};
subj.help = {'Data for this subject.  The same parameters are used within subject.'};

data.type = 'repeat';
data.name = 'Data';
data.values = {subj};
data.num  = [1 Inf];
data.help = {'List of subjects. Images of each subject should be warped differently.'};

est.type = 'branch';
est.name = 'Normalise: Estimate';
est.tag  = 'est';
est.val  = {data,eoptions};
est.prog = @estimate;
est.vfiles = @vfiles_estimate;
est.help = {[...
'Computes the warp that best registers a source image (or series of ',...
'source images) to match ',...
'a template, saving it to a file imagename''_sn.mat''.']};

%------------------------------------------------------------------------

subj.type = 'branch';
subj.name = 'Subject';
subj.tag  = 'subj';
subj.val  = {matname,scansr};
subj.help = {'Data for this subject.  The same parameters are used within subject.'};

data.type = 'repeat';
data.name = 'Data';
data.values = {subj};
data.num  = [1 Inf];
data.help = {'List of subjects. Images of each subject should be warped differently.'};

writ.type = 'branch';
writ.name = 'Normalise: Write';
writ.tag  = 'write';
writ.val  = {data,roptions};
writ.prog = @write;
writ.vfiles = @vfiles_write;
writ.help = {[...
'Allows previously estimated warps (stored in imagename''_sn.mat'' files) ',...
'to be applied to series of images.']};

%------------------------------------------------------------------------

subj.type = 'branch';
subj.name = 'Subject';
subj.tag  = 'subj';
subj.val  = {source, wtsrc, scansr};
subj.help = {'Data for this subject.  The same parameters are used within subject.'};

data.type = 'repeat';
data.name = 'Data';
data.values = {subj};
data.num  = [1 Inf];
data.help = {'List of subjects. Images of each subject should be warped differently.'};

estwrit.type = 'branch';
estwrit.name = 'Normalise: Estimate & Write';
estwrit.tag  = 'estwrite';
estwrit.val  = {data,eoptions,roptions};
estwrit.prog = @estwrite;
estwrit.vfiles = @vfiles_estwrite;
estwrit.help = {[...
'Computes the warp that best registers a source image (or series of ',...
'source images) to match ',...
'a template, saving it to the file imagename''_sn.mat''. ',...
'This option also allows the contents of the imagename''_sn.mat'' ',...
'files to be applied to a series of images.']};

%------------------------------------------------------------------------

opts.type = 'repeat';
opts.name = 'Normalise';
opts.tag  = 'normalise';
opts.values = {est,writ,estwrit};
opts.num  = [1 Inf];
opts.modality = {'FMRI','PET','VBM'};
p1 = [...
'This module spatially (stereotactically) normalises MRI, PET or SPECT ',...
'images into a standard space defined by some ideal model or template ',...
'image[s].  The template images supplied with SPM conform to the space ',...
'defined by the ICBM, NIH P-20 project, and approximate that of the ',...
'the space described in the atlas of Talairach and Tournoux (1988). ',...
'The transformation can also be applied to any other image that has ',...
'been coregistered with these scans.'];
p2 = [...
'Generally, the algorithms work by minimising the sum of squares ',...
'difference between the image which is to be normalised, and a linear ',...
'combination of one or more template images.  For the least squares ',...
'registration to produce an unbiased estimate of the spatial ',...
'transformation, the image contrast in the templates (or linear ',...
'combination of templates) should be similar to that of the image from ',...
'which the spatial normalisation is derived.  The registration simply ',...
'searches for an optimum solution.  If the starting estimates are not ',...
'good, then the optimum it finds may not find the global optimum.'];
p3 = [...
'The first step of the normalisation is to determine the optimum ',...
'12-parameter affine transformation.  Initially, the registration is ',...
'performed by matching the whole of the head (including the scalp) to ',...
'the template.  Following this, the registration proceeded by only ',...
'matching the brains together, by appropriate weighting of the template ',...
'voxels.  This is a completely automated procedure (that does not ',...
'require ``scalp editing'') that discounts the confounding effects of ',...
'skull and scalp differences.   A Bayesian framework is used, such that ',...
'the registration searches for the solution that maximises the a ',...
'posteriori probability of it being correct /* \cite{ashburner97b} */.  i.e., it maximises the ',...
'product of the likelihood function (derived from the residual squared ',...
'difference) and the prior function (which is based on the probability ',...
'of obtaining a particular set of zooms and shears).'];
p4 = [...
'The affine registration is followed by estimating nonlinear deformations, ',...
'whereby the deformations are defined by a linear combination of three ',...
'dimensional discrete cosine transform (DCT) basis functions /* \cite{ashburner99a} */.  The default ',...
'options result in each of the deformation fields being described by 1176',...
'parameters, where these represent the coefficients of the deformations in ',...
'three orthogonal directions.  The matching involved simultaneously ',...
'minimising the membrane energies of the deformation fields and the ',...
'residual squared difference between the images and template(s).'];
p5 = [...
'The primarily use is for stereotactic normalisation to facilitate inter-subject ',...
'averaging and precise characterisation of functional anatomy /* \cite{ashburner97bir} */.  It is ',...
'not necessary to spatially normalise the data (this is only a ',...
'pre-requisite  for  inter-subject averaging or reporting in the ',...
'Talairach space).  If you wish to circumnavigate this step  (e.g. if ',...
'you have single slice data or do not have an appropriate high ',...
'resolution MRI scan) simply specify where you think the  anterior ',...
'commissure  is  with  the  ORIGIN in the header of the first scan ',...
'(using the ''Display'' facility) and proceed directly  to ''Smoothing''',...
'or ''Statistics''.'];
p6 = [...
'All normalised *.img scans are written to the same subdirectory as ',...
'the original *.img, prefixed with a ''w'' (i.e. w*.img).  The details ',...
'of the transformations are displayed in the results window, and the ',...
'parameters are saved in the "*_sn.mat" file.'];
opts.help = {p1,'',...
p2,'',p3,'',p4,'',...
p5,'',...
p6};
%------------------------------------------------------------------------

return;
%------------------------------------------------------------------------

%------------------------------------------------------------------------
function estimate(varargin)
job    = varargin{1};
o      = job.eoptions;
eflags = struct(...
	'smosrc', o.smosrc,...
	'smoref', o.smoref,...
	'regtype',o.regtype,...
	'cutoff', o.cutoff,...
	'nits',   o.nits,...
	'reg',    o.reg);

for i=1:length(job.subj),
	[pth,nam,ext,ind] = spm_fileparts(strvcat(job.subj(i).source{:}));
	matname = fullfile(pth,[nam '_sn.mat']);
	spm_normalise(strvcat(job.eoptions.template{:}),...
		strvcat(job.subj(i).source{:}), matname,...
		strvcat(job.eoptions.weight{:}), strvcat(job.subj(i).wtsrc{:}), eflags);
end;
return;
%------------------------------------------------------------------------

%------------------------------------------------------------------------
function write(varargin)
job    = varargin{1};
o      = job.roptions;
rflags = struct(...
	'preserve',o.preserve,...
	'bb',      o.bb,...
	'vox',     o.vox,...
	'interp',  o.interp,...
	'wrap',    o.wrap);

for i=1:length(job.subj),
	spm_write_sn(strvcat(job.subj(i).resample{:}),...
		strvcat(job.subj(i).matname{:}),rflags);
end;
return;
%------------------------------------------------------------------------
 
%------------------------------------------------------------------------
function estwrite(varargin)
job    = varargin{1};
o      = job.eoptions;
eflags = struct(...
	'smosrc', o.smosrc,...
	'smoref', o.smoref,...
	'regtype',o.regtype,...
	'cutoff', o.cutoff,...
	'nits',   o.nits,...
	'reg',    o.reg);
o      = job.roptions;
rflags = struct(...
	'preserve',o.preserve,...
	'bb',      o.bb,...
	'vox',     o.vox,...
	'interp',  o.interp,...
	'wrap',    o.wrap);

for i=1:length(job.subj),
    [ pth,nam ] = spm_fileparts(deblank(job.subj(i).source{:}));
    matname     = fullfile(pth,[nam,'_sn.mat']);
    spm_normalise(strvcat(job.eoptions.template{:}),...
        strvcat(job.subj(i).source{:}), matname,...
        strvcat(job.eoptions.weight{:}), strvcat(job.subj(i).wtsrc{:}), eflags);
    spm_write_sn(strvcat(job.subj(i).resample{:}), matname, rflags);
end;
return;
%------------------------------------------------------------------------
 
%------------------------------------------------------------------------
function vf = vfiles_estimate(varargin)
job = varargin{1};
vf  = cell(length(job.subj),1);
for i=1:length(job.subj),
    [pth,nam,ext,num] = spm_fileparts(deblank(job.subj(i).source{:}));
    vf{i} = fullfile(pth,[nam,'_sn.mat']);
end;
%------------------------------------------------------------------------

%------------------------------------------------------------------------
function vf = vfiles_estwrite(varargin)
job = varargin{1};
vf  = cell(length(job.subj),1);
for i=1:length(job.subj),
    [pth,nam,ext,num] = spm_fileparts(deblank(job.subj(i).source{:}));
    vf{i} = fullfile(pth,[nam,'_sn.mat']);
end;
for i=1:length(job.subj),
    res = job.subj(i).resample;
    vf1 = cell(1,length(res));
    for j=1:length(res),
        [pth,nam,ext,num] = spm_fileparts(res{j});
        vf1{j} = fullfile(pth,['w', nam, ext, num]);
    end;
    vf = {vf{:} vf1{:}};
end;
%------------------------------------------------------------------------

%------------------------------------------------------------------------
function vf = vfiles_write(varargin)
job = varargin{1};
vf  = {};
for i=1:length(job.subj),
    res = job.subj(i).resample;
    vf1 = cell(1,length(res));
    for j=1:length(res),
        [pth,nam,ext,num] = spm_fileparts(res{j});
        vf1{j} = fullfile(pth,['w', nam, ext, num]);
    end;
    vf = {vf{:} vf1{:}};
end;
