function job = spm_config_hdw
% Configuration file for specification of fMRI model
%_______________________________________________________________________
% Copyright (C) 2006 Wellcome Department of Imaging Neuroscience

% John Ashburner
% $Id$

% Define inline types.
%-----------------------------------------------------------------------
entry = inline(['struct(''type'',''entry'',''name'',name,'...
    '''tag'',tag,''strtype'',strtype,''num'',num)'],...
    'name','tag','strtype','num');

files = inline(['struct(''type'',''files'',''name'',name,'...
    '''tag'',tag,''filter'',fltr,''num'',num)'],...
    'name','tag','fltr','num');

mnu = inline(['struct(''type'',''menu'',''name'',name,'...
    '''tag'',tag,''labels'',{labels},''values'',{values})'],...
    'name','tag','labels','values');

branch = inline(['struct(''type'',''branch'',''name'',name,'...
    '''tag'',tag,''val'',{val})'],...
    'name','tag','val');

repeat = inline(['struct(''type'',''repeat'',''name'',name,'...
    '''tag'',tag,''values'',{values})'],...
    'name','tag','values');

choice = inline(['struct(''type'',''choice'',''name'',name,'...
    '''tag'',tag,''values'',{values})'],...
    'name','tag','values');
%-----------------------------------------------------------------------

addpath(fullfile(spm('dir'),'toolbox','HDW'));

ref  = files('Reference Image','ref','image',1);
ref.help = {'This is the reference image, which remains stationary.'};

mov  = files('Moved Image','mov','image',1);
mov.help = {'This is the moved image, which is warped to match the reference.'};
fles = branch('Subject','data',{ref,mov});
fles.help = {[...
'Two images of the same subject, which are to be registered together.  ',...
'Prior to nonlinear high-dimensional warping, the images should be rigidly registered with each other.']};

fles = repeat('Subjects','data',{fles});
fles.help = {[...
'Specify pairs of images to match together.']};

nits = entry('Iterations','nits','n',[1 1]);
nits.help = {'Number of iterations for the bias correction'};
nits.val  = {8};

biasfwhm    = mnu('Bias FWHM','fwhm',{...
'30mm cutoff','40mm cutoff','50mm cutoff','60mm cutoff','70mm cutoff',...
'80mm cutoff','90mm cutoff','100mm cutoff','110mm cutoff','120mm cutoff',...
'130mm cutoff','140mm cutoff','150mm cutoff','No correction'},...
{30,40,50,60,70,80,90,100,110,120,130,140,150,Inf});
biasfwhm.val  = {60};
biasfwhm.help = {[...
'FWHM of Gaussian smoothness of bias. ',...
'If your intensity nonuniformity is very smooth, then choose a large ',...
'FWHM. This will prevent the algorithm from trying to model out intensity variation ',...
'due to different tissue types. The model for intensity nonuniformity is one ',...
'of i.i.d. Gaussian noise that has been smoothed by some amount, ',...
'before taking the exponential. ',...
'Note also that smoother bias fields need fewer parameters to describe them. ',...
'This means that the algorithm is faster for smoother intensity nonuniformities.']};

biasreg = mnu('Bias regularisation','reg',{...
'no regularisation','extremely light regularisation',...
'very light regularisation','light regularisation',...
'medium regularisation','heavy regularisation',...
'very heavy regularisation','extremely heavy regularisation'},...
{0, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3});
biasreg.val  = {1e-6};
biasreg.help = {[...
'We know a priori that intensity variations due to MR physics tend to be spatially smooth, ',...
'whereas those due to different tissue types tend to contain more high frequency information. ',...
'A more accurate estimate of a bias field can be obtained by including prior knowledge about ',...
'the distribution of the fields likely to be encountered by the correction algorithm. ',...
'For example, if it is known that there is little or no intensity non-uniformity, then it would be wise ',...
'to penalise large values for the intensity nonuniformity parameters. ',...
'This regularisation can be placed within a Bayesian context, whereby the penalty incurred is the negative ',...
'logarithm of a prior probability for any particular pattern of nonuniformity.']};

lmreg = mnu('Levenberg-Marquardt regularisation','lmreg',{...
'no regularisation','extremely light regularisation',...
'very light regularisation','light regularisation',...
'medium regularisation','heavy regularisation',...
'very heavy regularisation','extremely heavy regularisation'},...
{0, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3});
lmreg.val  = {1e-6};
lmreg.help = {[...
'Levenberg-Marquardt regularisation keeps the bias correction part stable. ',...
'Higher values means more stability, but slower convergence.']};

bias_opts = branch('Bias Correction Options','bias_opts',{nits,biasfwhm,biasreg,lmreg});
bias_opts.help = {[...
'MR images are usually corrupted by a smooth, spatially varying artifact that modulates the intensity ',...
'of the image (bias). ',...
'These artifacts, although not usually a problem for visual inspection, can impede automated ',...
'processing of the images.'],...
[...
'Before registering the images, an approximate bias correction is estimated for the moved image. ',...
'This is based on minimising the difference between the images an a symmetric way. ',...
'Prior to registering the images, they should be rigidly aligned together.  ',...
'The bias correction is estimated once for these aligned images.']};

warpreg = entry('Warping regularisation','reg','e',[1 1]);
warpreg.val = {4};
warpreg.help = {[...
'There is a tradeoff between the smoothness of the estimated warps, and the difference ',...
'between the registered images.  Higher values mean smoother warps, at the expense of ',...
'a lower mean squared difference between the images.']};

nits = entry('Iterations','nits','n',[1 1]);
nits.help = {'Number of iterations for the warping.'};
nits.val  = {8};

warp_opts = branch('Warping Options','warp_opts',{nits,warpreg});
warp_opts.help = {'There are a couple of user-customisable warping options.'};

job = branch('High-Dimensional Warping','hdw',{fles,bias_opts,warp_opts});
job.prog = @spm_hdw;
job.help = {[...
'This toolbox is a Bayesian method for three dimensional registration of brain images/* \cite{ashburner00a} */. ',...
'A finite element approach is used to obtain a maximum a posteriori (MAP) estimate of ',...
'the deformation field at every voxel of a template volume.  ',...
'The priors used by the MAP estimate penalize unlikely deformations and enforce a ',...
'continuous one-to-one mapping.  ',...
'The deformations are assumed to have some form of symmetry, in that priors describing ',...
'the probability distribution of the deformations should be identical to those for the ',...
'inverses (i.e., warping brain A to brain B should not be different probablistically ',...
'from warping B to A).  ',...
'A gradient descent algorithm is used to estimate the optimum deformations.'],...
['Deformation fields are written with the same name as the moved image, but with "y_" prefixed ',...
'on to the filename.  Jacobian determinant images are also written (prefixed by "jy_").']};
