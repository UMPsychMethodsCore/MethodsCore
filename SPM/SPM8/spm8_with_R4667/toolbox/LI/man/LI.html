<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of LI</title>
  <meta name="keywords" content="LI">
  <meta name="description"
 content="This is li.m, the main function of the LI-toolbox:">
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt; <a href="index.html">.</a>
&gt; LI.m</div>
<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for .&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->
<h1>LI
</h1>
<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^"
 src="../up.png" border="0"></a></h2>
<div class="box"><strong>This is li.m, the main function of the
LI-toolbox:</strong></div>
<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^"
 src="../up.png" border="0"></a></h2>
<div class="box"><strong>function [my_li] = LI(out,L,R); </strong></div>
<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^"
 src="../up.png" border="0"></a></h2>
<div class="fragment">
<pre class="comment">This is li.m, the main function of the LI-toolbox:<br>a tool to calculate lateralization indices.<br><br>Call with li(2) to generate file-output; passing three input<br>arguments enables file selection for custom left/right masks.<br><br>The toolbox can also be scripted by supplying a number of parameters<br>as a structure to the toolbox; if 'out' is a structure, the following<br>parameters are necessary:<br><br>A    = char array (path or paths to contrast images, one image per line)<br>B1   = 1 (frontal)<br>      = 2 (parietal)<br>      = 3 (temporal)<br>      = 4 (occipital)<br>      = 5 (cingulate)<br>      = 6 (central)<br>      = 7 (cerebellar)<br>      = 8 (gray matter)<br>      = 9 (all standard masks)<br>      = 10 (no mask)<br>      = 11 (custom, enables interactive selection [somewhat besides the point of scripting, but...])<br>      = char array (path or paths to inclusive mask(s), one image per line)<br>C1   = 1 (standard exclusive mask, midline -5 mm)<br>      = 2 (standard exclusive mask, midline -10 mm)<br>      = 3 (no exclusive mask)<br>      = 4 (custom, enables interactive selection)<br>      = char array (path or paths to exclusice mask(s), one image per line)<br>thr1 = 1 (use same threshold for all images)<br>      = 0 (individual thresholding for all images)<br>      = -1 (adaptive thresholding<br>      = -2 (rank-based thresholding)<br>      = -3 (iterative thresholding, LI-curves)<br>      = -4 (no threshold)<br>      = -5 (bootstrapping)<br><br>Such a structure may be generated by using <br>out = struct('A','YOUR_IMAGE','B1',1,'C1',1,'thr1',-5);<br><br>upon which LI(out) will analyze YOUR_IMAGE in the frontal lobe (B1 = 1),<br>excluding the midline (C1 = 1), using the bootstrapping approach (thr1 = -5)<br><br>There are also optional arguments which may or may not be supplied: default<br>values will be used if they are missing. Note that even when scripting, you <br>can still supply custom left and right mask images.<br><br>pre  = 0 (default)<br>      = 1 (enables preprocessing for custom masks, only necessary if B1 &gt; 10 or char)<br>thr3 = 0 (default; meaningless if not thr1 = 1; if so, adapt value to your needs)<br>      = [3 4 4 5] (supplies multiple thresholds if thr1 = 2)<br>op   = 1 (use optional data clustering; may not be allowed)<br>      = 2 (use optional variance weighting<br>      = 3 (use combined clustering and variance weighting; may not be allowed)<br>      = 4 (default; no optional steps)<br>vc   = 1 (use total voxel count; may not be allowed)<br>      = 0 (use total voxel values; default)<br>ni    = 0 (images not normalized)<br>      = 1 (images normalized; default)<br>outfile = string with name of a custom output file (defaults to 'li.txt')<br><br>Alternatively, you can use the toolbox in interactive mode; in this case,<br>you will have to select a contrast image first, preferrably <br>a spmT_*.image. This *should* be normalized (ideally using the<br>template-space bounding box and 2x2x2mm); although the contrast is <br>explicitly matched to the masks if other dimensions (or unnormalized<br>images) are used, errors will be minimal this way.<br><br>Then, any number of standard or custom mask can be selected; custom <br>ones can be mirrored and binarized to avoid size biases. A mask will <br>be applied to any number of statistical images (contrasts) chosen above.<br>This is repeated for all masks and all contrasts.<br><br>A mask defining tissue to exclude can also be chosen,<br>again standard (exclusion of midline structures) or a custom one.<br><br>A threshold can be entered for all or for each<br>contrast image individually, or it can be derived from<br>the data, using an adaptive (mean intensity[positive Voxels]<br>or a ranking procedure. No threshold is also possible. An<br>spmT_image is necessary for the ranking procedure, otherwise<br>any image can be assessed, also from the non-spm-world (yes,<br>there is one :). Variance weighting (see below), though, will not work<br>in this case. Lastly, iterative thresholding is available which<br>will yield nice lateralization curves as a function of thresholds.<br>An extension to this is based on a bootstrap approach.<br><br>Data clustering refers to the Gaussian smoothing of the contrast<br>image prior to thresholding, which will remove outliers and <br>effectively cluster the data. This is an optional step.<br><br>Also optionally, variance weighting can be done, taking into acount<br>the variability of each voxel as assessed during the statistical<br>analysis and as expressed in the ResMS.img. Both optional steps <br>can also be combined. They are only recommended if you have reason<br>to believe that outliers influence your results; they can have a <br>substantial influence on your results, so be careful here.<br><br>The results can be calculated on the voxel values (seems to<br>make more sense, but may be more vulnerable to outliers)<br>or on the absolute voxel count.<br><br>Finally, results are checked for small numbers of voxel (default<br>is n=10) or small clusters (default is k=5); an appropriate warning<br>is given if either is not met, and calculations are aborted if n=0.<br><br>The toolbox was developed under and for spm2 and spm5, and it should<br>work on spm-versions higher than that; it expects <br>spm_dir/toolbox/LI/data directory with masks and a number of<br>LI_* helper files, some of which are hacked (lean :) versions<br>of original spm_functions. I am most indebted to those of you<br>who really know how to write code (mainly John Ashburner,<br>Volkmar Glauche, Tom Nichols and many others), so I could steal it.<br>As it is in parts based on files distributed under the GNU public<br>license, the same applies to this toolbox and all files coming with it.<br>Please see the accompanying Readme.txt for more infos.<br>!USE AT YOUR OWN RISK! <br>Yours, Marko Wilke<br><br></pre>
</div>
<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img
 alt="^" src="../up.png" border="0"></a></h2>
This function calls:
<ul style="list-style-image: url(../matlabicon.gif);">
  <li><a href="LI.html" class="code"
 title="function [my_li] = LI(out,L,R);">LI</a> This is li.m, the main
function of the LI-toolbox:</li>
  <li><a href="LI_boot.html" class="code"
 title="function [thrs] = LI_boot(A,B,C,out,sm,vw,pre,L,R);">LI_boot</a>
Function to iteratively calculate lateralization indices,</li>
  <li><a href="LI_imcalc.html" class="code"
 title="function [Q,Vo] = spm_imcalc_ui(P,Q,f,flags,varargin)">LI_imcalc</a>
Perform algebraic functions on images</li>
  <li><a href="LI_iter.html" class="code"
 title="function [thrs, lis] = LI_iter(A,B,C,out,sm,vw,pre,L,R);">LI_iter</a>
function [lis, thrs, voxl, voxr] = LI_iter(A,B,C,out,sm,vw,pre,L,R);</li>
  <li><a href="LI_normalise.html" class="code"
 title="function params = LI_normalise(VG,VF,matname,VWG,VWF)">LI_normalise</a>
Spatial (stereotactic) normalization</li>
  <li><a href="LI_print.html" class="code"
 title="function LI_print(print_str,F,fnote);">LI_print</a> This is a
stripped-down version of</li>
  <li><a href="LI_rank.html" class="code"
 title="function [lo] = LI_rank(a);">LI_rank</a> This function is used
for ranking t-values in order</li>
  <li><a href="LI_reslice.html" class="code"
 title="function LI_reslice(P,flags)">LI_reslice</a> Rigid body
reslicing of images; modified version, part of the LI-toolbox</li>
  <li><a href="LI_write_sn.html" class="code"
 title="function VO = spm_write_sn(V,prm,flags,extras)">LI_write_sn</a>
Write Out Warped Images.</li>
</ul>
This function is called by:
<ul style="list-style-image: url(../matlabicon.gif);">
  <li><a href="LI.html" class="code"
 title="function [my_li] = LI(out,L,R);">LI</a> This is li.m, the main
function of the LI-toolbox:</li>
  <li><a href="LI_boot.html" class="code"
 title="function [thrs] = LI_boot(A,B,C,out,sm,vw,pre,L,R);">LI_boot</a>
Function to iteratively calculate lateralization indices,</li>
  <li><a href="LI_iter.html" class="code"
 title="function [thrs, lis] = LI_iter(A,B,C,out,sm,vw,pre,L,R);">LI_iter</a>
function [lis, thrs, voxl, voxr] = LI_iter(A,B,C,out,sm,vw,pre,L,R);</li>
  <li><a href="LI_test.html" class="code"
 title="function [my_li] = LI(out,L,R);">LI_test</a> This is li_test.m,
the left-right-helper function of the LI-toolbox:</li>
</ul>
<!-- crossreference -->
<div class="fragment">
<pre><span class="comment"><br></span></pre>
</div>
<hr>
<address>Generated on Fri 16-Jun-2006 10:17:49 by <strong><a
 href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong>
&copy; 2003</address>
</body>
</html>
