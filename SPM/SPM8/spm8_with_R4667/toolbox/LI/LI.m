function [my_li] = LI(out,L,R);
% This is li.m, the main function of the LI-toolbox:
% a tool to calculate lateralization indices.
% 
% Call with li(2) to generate file-output; passing three input
% arguments enables file selection for custom left/right masks.
%
% The toolbox can also be scripted by supplying a number of parameters
% as a structure to the toolbox; if 'out' is a structure, the following
% parameters are necessary:
%
% A    = char array (path or paths to input images, one image per line)
% B1   = 1 (frontal)
%       = 2 (parietal)
%       = 3 (temporal)
%       = 4 (occipital)
%       = 5 (cingulate)
%       = 6 (central)
%       = 7 (cerebellar)
%       = 8 (gray matter)
%       = 9 (all standard masks)
%       = 10 (no mask)
%       = 11 (custom, enables interactive selection [somewhat besides the point of scripting, but...])
%       = char array (path or paths to inclusive mask(s), one image per line)
% C1   = 1 (standard exclusive mask, midline -5 mm)
%       = 2 (standard exclusive mask, midline -10 mm)
%       = 3 (no exclusive mask)
%       = 4 (custom, enables interactive selection)
%       = char array (path or paths to exclusice mask(s), one image per line)
% thr1 = 1 (use same threshold for all images)
%       = 0 (individual thresholding for all images)
%       = -1 (adaptive thresholding
%       = -2 (rank-based thresholding)
%       = -3 (iterative thresholding, LI-curves)
%       = -4 (no threshold)
%       = -5 (bootstrapping)
% 
% Such a structure may be generated by using 
% out = struct('A','YOUR_IMAGE','B1',1,'C1',1,'thr1',-5);
%
% upon which LI(out) will analyze YOUR_IMAGE in the frontal lobe (B1 = 1),
% excluding the midline (C1 = 1), using the bootstrapping approach (thr1 = -5)
%
% There are also optional arguments which may or may not be supplied: default
% values will be used if they are missing. Note that even when scripting, you 
% can still supply custom left and right mask images.
% 
% pre  = 0 (default)
%       = 1 (enables preprocessing for custom masks, only necessary if B1 > 10 or char)
% thr3 = 0 (default; meaningless if not thr1 = 1; if so, adapt value to your needs)
%       = [3 4 4 5] (supplies multiple thresholds if thr1 = 2)
% op   = 1 (use optional data clustering; may not be allowed)
%       = 2 (use optional variance weighting
%       = 3 (use combined clustering and variance weighting; may not be allowed)
%       = 4 (default; no optional steps)
% vc   = 1 (use total voxel count; may not be allowed)
%       = 0 (use total voxel values; default)
% ni    = 0 (images not normalized)
%       = 1 (images normalized; default)
% outfile = string with name of a custom output file (defaults to 'li.txt')
%
% Alternatively, you can use the toolbox in interactive mode; in this case,
% you will have to select an input image first, preferrably 
% a spmT_*.image. This *should* be normalized (ideally using the
% template-space bounding box and 2x2x2mm); although the input is 
% explicitly matched to the masks if other dimensions (or unnormalized
% images) are used, errors will be minimal this way.
%
% Then, any number of standard or custom mask can be selected; custom 
% ones can be mirrored and binarized to avoid size biases. A mask will 
% be applied to any number of statistical images (inputs) chosen above.
% This is repeated for all masks and all inputs.
%
% A mask defining tissue to exclude can also be chosen,
% again standard (exclusion of midline structures) or a custom one.
%
% A threshold can be entered for all or for each
% input image individually, or it can be derived from
% the data, using an adaptive (mean intensity[positive Voxels]
% or a ranking procedure. No threshold is also possible. An
% spmT_image is necessary for the ranking procedure, otherwise
% any image can be assessed, also from the non-spm-world (yes,
% there is one :). Variance weighting (see below), though, will not work
% in this case. Lastly, iterative thresholding is available which
% will yield nice lateralization curves as a function of thresholds.
% An extension to this is based on a bootstrap approach.
%
% Data clustering refers to the Gaussian smoothing of the input
% image prior to thresholding, which will remove outliers and 
% effectively cluster the data. This is an optional step.
%
% Also optionally, variance weighting can be done, taking into acount
% the variability of each voxel as assessed during the statistical
% analysis and as expressed in the ResMS.img. Both optional steps 
% can also be combined. They are only recommended if you have reason
% to believe that outliers influence your results; they can have a 
% substantial influence on your results, so be careful here.
%
% The results can be calculated on the voxel values (seems to
% make more sense, but may be more vulnerable to outliers)
% or on the absolute voxel count.
%
% Finally, results are checked for small numbers of voxel (default
% is n=10) or small clusters (default is k=5); an appropriate warning
% is given if either is not met, and calculations are aborted if n=0.
%
% The toolbox was developed under and for spm2 and spm5, but now (in order
% to avoid incompatibilites) only works on spm-versions 8 or higher; it expects 
% spm_dir/toolbox/LI/data directory with masks and a number of
% LI_* helper files, some of which are hacked (lean :) versions
% of original spm_functions. I am most indebted to those of you
% who really know how to write code (mainly John Ashburner,
% Volkmar Glauche, Tom Nichols and many others), so I could steal it.
% As it is in parts based on files distributed under the GNU public
% license, the same applies to this toolbox and all files coming with it.
% Please see the accompanying Readme.txt for more infos.
% !USE AT YOUR OWN RISK! 
% Yours, Marko Wilke

% ==========================================================================================================
%                                          Preludes: settings, inputs, etc.
% ==========================================================================================================


% get a nice and clean environment
  clc
  fg = spm_figure('Findwin','Graphics');
  fi = spm_figure('Findwin','Interactive');
  spm_figure('Clear',fg);
  spm_figure('Clear',fi);


% avoid display of Divide by Zero
  warning off MATLAB:divideByZero


% using variable PP to inform user
  PP = 'Welcome to the LI toolbox';
  spm('FigName', PP);


% set variables for common cases; change stdpth if your masks reside elsewhere
  stdpth = [spm('Dir') filesep 'toolbox' filesep 'LI' filesep 'data'];
  global script ni
  thr0 = 1;
  vc = 1;
  sm = 1;
  pre = 0;
  ni = 2;
  B2 = 0;
  script = 0;


% set name for output file; enable alternative if you want to include the date
  outfile = 'li.txt';
  % outfile = spm_input('Name for output file','!+1','s','li.txt');
  % outfile = ['li_' date '.txt'];  % watch out if run overnight


% get version; abort if minimum version not found
  ver = spm('ver');
  if str2num(ver(4:end)) < 8

	uiwait(msgbox(['Sorry, you seem to be using an old version of spm (' ver '); this toolbox expects spm8 or later. We apologize for the inconvenience...'], 'Warning'));
	return;
  end;


% set critical number of voxels (ncr), minimum cluster size (k), and minimum number of voxels (nabort)
  ncr = 10;     % default: 10
  k = 5;        % default: 5
  nabort = 5;   % default: 5


% ask how the output is supposed to be; defined via command line; could be re-enabled below
  if nargin > 0

	% check if complex input, indicating the wish to script...
	  if isstruct(out) 
		  input = out;
		  out = 2;
		  script = 1;

		% examine input, check optional arguments
		  if isfield(input, 'pre') == 0
			pre = 0;
			input.pre = pre;
		  else
			if ischar(input.B1) | input.B1 == 11
				pre = input.pre;
			else
				pre = 0;
			end;
		  end;

		  if isfield(input, 'thr3') == 0
			thr3 = 0;
			input.thr3 = thr3;
		  else
			if input.thr1 == 1 | input.thr1 == 2
				thr3 = input.thr3;
			else
				thr3 = 0;
			end;
		  end;

		  if isfield(input, 'op') == 0
			op = 4;
			input.op = op;
		  end;

		  if isfield(input, 'vc') == 0
			vc = 0;
			input.vc = vc;
		  end;

		  if isfield(input, 'outfile') == 1
			outfile = input.outfile;
		  end;

		  if isfield(input, 'ni') == 0
			ni = 1;
			input.ni = ni;
		  else
			ni = input.ni;
		  end;
			
	  else
		out = out;
	  end;
  else
	out = 1;
	% to routinely ask, re-enable here; to routinely write to file, change out to 2 above 
	% out = spm_input('Output to screen or screen/file ?','+1','b',[' Screen| Screen/File'],[1 2],1);
  end;


% =====  Get images; need spmT for ranking procedure  =====
  if script == 0

	  A = spm_select([1 Inf],'image','Select input Image(s)',[],pwd,'spm[TF]_.*$');
  else
	  A = input.A;
  end;


% =====  check how images should be thresholded  ===== 
  if script == 0
	thr1 = spm_input('Select thresholding method','+1','m',...
		[' One threshold for All| Individual threshold input|'...
		' Adaptive threshold determination| Ranking procedure|'...
		' Iterative thresholding (LI curves)| No threshold| Bootstrap'],[1 0 -1 -2 -3 -4 -5],-5);
  else
	thr1 = input.thr1;
  end;

  if thr1 == 1

	% if the same threshold is chosen, get value here
 	  meth = '(all)';
	  if script == 0
		thr3 = spm_input('Threshold for all input images','!+1','e',3);
	  else
		thr3 = input.thr3;
	  end;
	  thr = sprintf('file_vol.*(file_vol>%f)', thr3);
	  fprintf(['  Applying common threshold (thr = ' sprintf('%0g', thr3) ').' '\n']);

  elseif thr1 == 0

	% if individual thresholding is chosen, get values; inform user
	  meth = '(ind.)';
	  its = zeros(size(A,1),1);
	  if script == 0
		fprintf(['  Please enter thresholds for...' '\n']);
		for jj = 1:size(its)
			disp(['    - input image # ' num2str(jj) ': ' A(jj,:)]);
			fprintf('\n');
			it = spm_input(['Threshold for input  # ' num2str(jj)],'!+1','e',3);
			its(jj) = it;
		end;
	  else
		% make sure we have data for each input...
		  if size(input.thr3,2) == size(A,1)
			its = input.thr3;
			fprintf(['  Using individual thresholds ...' '\n']);
		  else
			uiwait(msgbox(['Number of provided thresholds (' num2str(size(input.thr3,2)) ') does not match number of provided images (' num2str(size(A,1)) ') - please provide correct number'], 'Inputs and thresholds do not match', 'warn'));
			fprintf(['  Please enter thresholds for...' '\n']);
			for jj = 1:size(its)
				disp(['    - input image # ' num2str(jj) ': ' A(jj,:)]);
				fprintf('\n');
				it = spm_input(['Threshold for input  # ' num2str(jj)],'!+1','e',3);
				its(jj) = it;
			end;
		  end;
	  end;


  elseif thr1 == -1

	% if adaptive threshold is chosen, leave definition for later
	  meth = '(adapt)';
	  fprintf(['  Applying adaptive threshold (intensity > mean_intensity[posVox]).' '\n']);

  elseif thr1 == -2

	% if ranking threshold is chosen, computation is below; inform user
	  meth = '(rank)';
	  fprintf(['  Applying rank-based thresholding.' '\n']);
	  sm = 0;
	  vc = 0;
	  cm = 'total voxel values'; 

  elseif thr1 == -3

	% if iterative threshold is chosen, computation is below; inform user
	  meth = '(iterative)';
	  fprintf(['  Applying iterative LI computation.' '\n']);
	  vc = 0;
	  cm = 'total voxel values'; 

  elseif thr1 == -4

	% if no threshold is chosen, set cases accordingly
	  meth = '(none)';
	  fprintf(['  Applying -no- threshold to input images.' '\n']);	
	  thr1 = 2;
	  vc = 0;
	  cm = 'total voxel values'; 
	  thr3 = 0;
	  thr = sprintf('file_vol.*(file_vol>%f)', thr3);

  elseif thr1 == -5

	% if bootstrapping is chosen, prepare passing to external function
	  meth = '(bootstrap)';
	  fprintf(['  Applying a bootstrap.' '\n']);	
	  vc = 0;
	  cm = 'total voxel values'; 
  end;


% ===== may choose mask for tissue to include, suggest lobes etc ===== 
  if script == 0
	B1 = spm_input('Select INclusive mask','!+1','m', ...
        	 [' Frontal Lobe| Parietal Lobe| Temporal Lobe|'...
		 ' Occipital Lobe| Cingulate| Central Gray matter (BG, Thalamus)|'...
		 ' Cerebellum| Gray Matter...| All Lobes| None| Custom...'], ...
		 [1 2 3 4 5 6 7 8 9 10 11],1);
  else
	B1 = input.B1;
  end;


  if ischar(B1)
	B = B1;
	B1 = 11;
  else
	if B1 == 1
		B = fullfile(stdpth,'LI-frontal-mask.img');
	elseif B1 == 2
		B = fullfile(stdpth,'LI-parietal-mask.img');
	elseif B1 == 3
		B = fullfile(stdpth,'LI-temporal-mask.img');
	elseif B1 == 4
		B = fullfile(stdpth,'LI-occipital-mask.img');
	elseif B1 == 5
		B = fullfile(stdpth,'LI-cingulate-mask.img');
	elseif B1 == 6
		B = fullfile(stdpth,'LI-central-mask.img');
	elseif B1 == 7
		B = fullfile(stdpth,'LI-cerebellar-mask.img');
	elseif B1 == 8
		if script == 0
			  B2 = spm_input('Standard or individual gray matter?','!+1','m', ...
	        	       	' Standard gray matter mask (provided)| Individual gray matter mask (select now)', ...
				[1 2],1);
		else
			% use standard mask by default; custom mask can still be provided when scripting via direct name input
			  B2 = 1;
		end;
	
		if B2 == 1
			  B = fullfile(stdpth,'LI-gray-matter-mask.img');
		else
			  if script == 0
				B3 = spm_select(1,'image','Select coregistered gray matter image',[],pwd,'c1.*');;
			  else
				B3 = input.B2;
			  end;
			  pre = 1;
			  B = B3;
		end;
	elseif B1 == 9
		m1 = fullfile(stdpth,'LI-frontal-mask.img');
		m2 = fullfile(stdpth,'LI-parietal-mask.img');
		m3 = fullfile(stdpth,'LI-temporal-mask.img');
		m4 = fullfile(stdpth,'LI-occipital-mask.img');
		m5 = fullfile(stdpth,'LI-cingulate-mask.img');
		m6 = fullfile(stdpth,'LI-central-mask.img');
		m7 = fullfile(stdpth,'LI-cerebellar-mask.img');
		B  = char({m1, m2, m3, m4, m5, m6, m7});
	elseif B1 == 10
		B = 'none';
	elseif B1 == 11
		B = spm_select([0 Inf],'image','INclusive Mask - Done for None',[],stdpth,'LI.*');
	
		if isempty(B)
			B = 'none';
		else
			pre = spm_input('Pre-process masks ?','+1','b',['Yes| No'],[1 0],0);
		end;
	end;
  end;


% now optionally choose mask for tissue to exclude, suggest midline
  if script == 0
	C1 = spm_input('Select EXclusive mask','!+1','m', ...
             ' Midline (+/- 5mm)| Midline (+/- 11mm)| None| Custom...', ...
	      [1 2 3 4],1);
  else
	C1 = input.C1;
  end;

  if ischar(C1)
	C = C1;
	C1 = 4;
  else
	if C1 == 1
		C = fullfile(stdpth,'LI-midline_5_ex.img');
	elseif C1 == 2
		C = fullfile(stdpth,'LI-midline_11_ex.img');
	elseif C1 == 3
		C = 'none';
	elseif C1 == 4
		C = spm_select(1,'image','EXclusive Mask - Done for None',[],stdpth,'*_ex.img');
		if isempty(C)
			C = 'none';
		end;
	end;
  end;


% ===== check optional steps (clustering, variance weighting, or both  ===== 
% don't offer smoothing for ranking approach (screws up t-distribution)
  if script == 0
	if sm == 1
		op = spm_input('Select Optional Steps','!+1','m', ...
		     ' Clustering| Variance weighting| Both| None', ...
		     [1 2 3 4],4);
	else
		op = spm_input('Select Optional Steps','!+1','m', ...
                     ' Variance weighting| None', ...
		     [2 4],4);
	end;
  else
	if sm == 1
		op = input.op;
	else
		if input.op == 2 | input.op == 4
			op = input.op;
		else
			fprintf(['  Clustering disallowed, reverting to no optional steps' '\n']);
			op = 4;
		end;
	end;
  end;


  if op == 1
	sm = 1;	vw = 0;	wi = 0;
	fprintf(['  Using data clustering.' '\n']);
  elseif op == 2
	sm = 0;	vw = 1;	wi = 1;
	fprintf(['  Using variance weighting.' '\n']);
  elseif op == 3
	sm = 1;	vw = 1;	wi = 1;
	fprintf(['  Using combined clustering and variance weighting.' '\n']);
  elseif op == 4
	sm = 0;	vw = 0;	wi = 0;
	fprintf(['  Using no optional steps.' '\n']);
  end;


% ===== now ask if voxel count or value should be used  ===== 
% don't offer for no threshold, ranking, smoothing or with iterations (use vv by default)
  if script == 0
	if vc ~=0 & sm == 0
		vc = spm_input('Use voxel count or voxel value?','+1','m',[' Voxel Count| Voxel Value'],[1 0],0);
	else
		vc = 0;
	end;
  else
	if vc ~=0 & sm == 0
		vc = input.vc;
	else
		vc = 0;
	end;
  end;

  if vc == 1
	cm = 'total voxel count';
	fprintf(['  Using total voxel count.' '\n']);
  else
	cm = 'total voxel values';
	fprintf(['  Using total voxel values.' '\n']);
  end;
	

% =====  if not specified, presume standard l/r images; ask specifically if more than one input arg  =====
  if nargin < 2

	L = fullfile(stdpth,'LI-left.img');
	R = fullfile(stdpth,'LI-right.img');

  elseif script == 0

	L = spm_select(1,'image','Select custom left Mask',[],stdpth,'.*');
	R = spm_select(1,'image','Select custom right Mask',[],stdpth,'.*');

  end;


% =====  check handedness of L/R images  =====
  M_L = spm_get_space(L);
  M_R = spm_get_space(R);
  if det(M_R(1:3,1:3)) * det(M_L(1:3,1:3))  < 0

	error(['  Caution: images for left (' L ') and right (' R ') are of different handedness, aborting!']);
  end;
  ori_R = R;
  ori_L = L;

% ==========================================================================================================
%                                          get down to business: start calculating
% ==========================================================================================================


% ===== start looping through all supplied input images ===== 
  ninputs = size(A,1);
  for i = 1:ninputs


	% identify file to check, load, get information
	  file_vol_ns = spm_vol(A(i,:));
	  file = file_vol_ns.fname;
	  file_ns = file;
	  check_dims = spm_get_space(A(i,:));
	  check_dims = sqrt(sum(check_dims(1:3,1:3).^2));


	% =====  assume correct, but double-check handedness of image under scrutiny  =====
	  R = ori_R;
	  L = ori_L;
	  M_C = spm_get_space(A(i,:));
	  if det(M_C(1:3,1:3)) * det(M_L(1:3,1:3))  < 0

		[p nm e v] = spm_fileparts(file_ns);
		fprintf(['  Handedness of image ' nm ' differs from standard assumption, adjusting L/R images...' '\n']);
		L = ori_R;
		R = ori_L;

	  end;


	% inform of progress
	  PP = ['Processing input image'];
	  spm('FigName', PP);


	% ===== Checking thresholding options  ===== 
	  if thr1 == 0
		% if individual thresholding was chosen above: get values fom its
		  thr3 = its(i);
		  thr = sprintf('file_vol.*(file_vol>%f)', thr3);

	  elseif thr1 == -1
		% if adaptive thresholding was chosen above:
		% should use only positive values for mean; count voxels
		  ad_vol = spm_read_vols(spm_vol(file));
		  ad_vol(isnan(ad_vol)) = 0;
		  temp = size(ad_vol(find(ad_vol>0)));
		  n_vox = temp(1);
		  s_vox = sum(ad_vol(find(ad_vol.*(ad_vol>0))));

		% divide (positive) total intensity by number of contributing voxels
		  thr3 = s_vox/n_vox;
		  thr = sprintf('file_vol.*(file_vol>%f)', thr3);

	  elseif thr1 == -2
		% if rank-based thresholding was chosen, pass to LI_rank for computation
		% NB: this will bail out if no supra-threshold values are found (p=0.05, FDR)
		  [thr3] = LI_rank(file);
			if isnan(thr3) == 1
				return;
			end;
		  file = 'LI_rank.img';

	  elseif thr1 == -3
		% if iterative thresholding was chosen, pass to LI_iter for computation;
		% for comparison purposes, set threshold to 0 in the display
		  [thrs, lis] = LI_iter(A,B,C,out,sm,vw,pre,B1,B2,outfile,L,R);
		  return

	  elseif thr1 == -4
		% if no thresholding is selected, only exclude negative values;
		  thr3 = 0;
		  thr = sprintf('file_vol.*(file_vol>%f)', thr3);

	  elseif thr1 == -5
		% if bootstrapping was chosen, pass to LI_boot for computation;
		  LI_boot(A,B,B1,B2,C,out,sm,vw,pre,outfile,L,R);
		  return
	  end;


	% ===== Checking other options  ===== 
	  if sm == 1 | vw == 1
		% Note that the smoothing factor sf will apply for both
		% smoothing and variance weighting (so combined use is possible)
		% Get voxel dimensions to allow for anisotropic smoothing;
		  sf = 3;
		  dim1 = sf*check_dims(1);
		  dim2 = sf*check_dims(2);
		  dim3 = sf*check_dims(3);
	  end;


	  if vw == 1
		% if variance weighting should be done, derive file name and check it
		% (before smooth changes it :); Else, warn and ask about it; note that
		% a non-fitting wi will screw things up badly.
		  [p nm e v] = spm_fileparts(file_ns);
		  wi = [p filesep 'ResMS' e];
		  if exist(wi, 'file') == 0
			waitfor(msgbox(['The corresponding variance weighting image for the input image ' (file_ns) ' was not found; please select (or abort) next!'], 'Variance weighting image not found!'));
			wi = spm_select([0 1],'image','Select weight - Done for none',[],pwd,'ResMS.img');
			if isempty(wi)
				vw = 0;
				wi = 'none';
				fprintf(['  Aborting variance weighting (weighting image not specified).' '\n']);
			end;
		  end;
		  if vw == 1
			  PP = 'Processing weighting image';
			  spm('FigName', PP);
			spm_smooth(wi, 'LI_weight.img', [dim1 dim2 dim3]);
			wi = 'LI_weight.img';
		  end;
	  end;


	  if sm == 1
		% if smoothing was chosen, implement here; 
		    PP = ['Smoothing input image'];
		    spm('FigName', PP);
		  spm_smooth(file_ns, 'LI_s_input.img', [dim1 dim2 dim3]);
		  file = 'LI_s_input.img';
	  end;


	% ===== check if images are in the right format (template bb, 2x2x2) =====
	% if not normalized, proceed to do an affine transformation; use random-to-random
	% transformation to avoid intensity/NaN problems ; if normalized, but
	% not to template space/our resolution, reslice only (rigid body)
	  check = spm_read_vols(file_vol_ns);
	  if check_dims./[2 2 2] ~= [1 1 1]
		check_dims = 0;
	  end;

	  if size(check,1) ~= 91 | size(check,2) ~= 109 | size(check,3) ~= 91 | check_dims == 0

		% ok, not in template space or not in our resolution; check once if all are normalized
		  if ni == 2
			if ninputs > 1
				ask = 'Are all input images normalized?';
			else
				ask = 'Is this input image normalized?';
			end;
			ni = spm_input(ask,'+1','m',[' Yes| No'],[1 0],1);
		  end;

		% set up variables for normalization/matching
		  [p nm e v] = spm_fileparts(file_ns);
		  p2 = spm_str_manip(p, 'a20');
		  VG = fullfile(stdpth,'randbrain.img');
		  VWG = fullfile(stdpth,'randmask.img');

		% this asks for each input individually; disabled since all constrasts should be either normalized or not
		% ni = spm_input(['Is the input from ' (p2) ' normalized?'],'+1','m',[' Yes| No'],[1 0],1);


 		if ni == 0
			  PP = ['Normalizing input image'];
			  spm('FigName', PP);
			VF = check;    VF(isnan(VF)) = 0;    VF(abs(VF)>0) = 1;
			VR = rand(size(VF,1),size(VF,2),size(VF,3)).*VF;
			Vn = file_vol_ns;
			Vn.fname = 'LI_rand.img';
			spm_write_vol(Vn,VR);

			LI_normalise(VG,'LI_rand.img','LI_normalize.mat',VWG,[]);
		        LI_write_sn(file,'LI_normalize.mat');

			if vw == 1
				LI_write_sn(wi,'LI_normalize.mat');
				[pwi nmwi ewi vwi] = spm_fileparts(wi);
				wi = fullfile(pwd,['LI_w_' nmwi ewi]);
			end;
			[p nm e v] = spm_fileparts(file);
			file = fullfile(pwd,['LI_w_' nm e]);
			file_vol = spm_read_vols(spm_vol(file));
			file_vol(isnan(file_vol)) = 0;


		elseif ni == 1
			  PP = ['Matching input image'];
			  spm('FigName', PP);
			  [p nm e v] = spm_fileparts(file);

			if vw == 1
				file_vol = LI_mreslice(VG,file,1,[],['LI_r_' nm e]);
				wi_vol   = LI_mreslice(VG,wi,1,[],0);
				wi_vol(isnan(wi_vol)) = 0;

			else
				file_vol = LI_mreslice(VG,file,1,[],['LI_r_' nm e]);
			end;
			file = fullfile(pwd,['LI_r_' nm e]);
			file_vol(isnan(file_vol)) = 0;

		end;
	  else

		file_vol = spm_read_vols(spm_vol(file));
		file_vol(isnan(file_vol)) = 0;
	  end;


	% ===== apply the threshold here (except for ranking, where this was already done) =====
	% if threshold = 0, at least take out negatives (disregarding deactivations); Common stuff first

	  if thr1 ~= -2
  		if thr0 == 0
			PP = 'Excluding negative voxels';
		  else
			PP = 'Thresholding input image';
		  end;
		    spm('FigName', PP);

		con_vol = eval(thr);
	  else
		con_vol = file_vol;
	  end;



	% ===== if voxel count thresholding was chosen above, convert to binary here ===== 
	  if vc == 1
		con_vol = con_vol>0;
	  end;


	% ===== start looping through all supplied mask images ===== 
	  nmasks = size(B,1);
	  for ii = 1:nmasks
        	mask = B(ii,:);
		abort = 0;

		% check if custom-mask was chosen, then pre-process; also make sure no NaNs are included
		  if pre == 1
			  PP = 'Preprocessing custom mask';
			  spm('FigName', PP);

			LI_imcalc({mask},'LI_complete_mask.img','i1>0.5',{[],[],['uint8'],0});

			if ni == 0
				  LI_write_sn('LI_complete_mask.img','LI_normalize.mat');
				  mask_c = 'LI_w_LI_complete_mask.img';
			elseif ni == 1
				  mask_c = 'LI_r_LI_complete_mask.img';
				  LI_mreslice(VG,'LI_complete_mask.img',1,0.1,mask_c);
			end;

			if B1 == 8 & B2 == 2
				% if a subject's own gm-segment is chosen, need to double-preprocess (smooth, flip, binarize)
				  spm_smooth(mask_c,'LI_s_ind_GM.img',[12]);
				  LI_imcalc({'LI_s_ind_GM.img'},'LI_complete_mask.img','(i1+flipud(i1))>0.5',{[],[],[],0});
				  mask_c = 'LI_complete_mask.img';
			else
				% if another mask is chosen, just flip and binarize
				  LI_imcalc({mask_c},'LI_complete_mask.img','(i1+(flipud(i1)))>0.1',{[],[],['uint8'],0});
				  mask_c = 'LI_complete_mask.img';
			end;
		  else
			mask_c = mask;
		  end;


		% ===== This is where the beef is  ===== 
		% Now mask thresholded input image with the mask and the LEFT/RIGHT hemi-mask and exclude
		% unwanted tissue as defined by the exclusive mask C. NB: mask image is binarized (again) to
		% safely avoid intermediate values due to interpolation. First, check which images are
		% necessary, specifically exclude NaN's, then do the calculations (about time)
		% OK: Ready...

		    PP = 'Masking input (L & R)';
		    spm('FigName', PP);

		% ...steady...
		  R_vol = spm_read_vols(spm_vol(R));    R_vol(isnan(R_vol)) = 0;
		  L_vol = spm_read_vols(spm_vol(L));    L_vol(isnan(L_vol)) = 0;
		  if strcmp(B,'none')~=1;    mask_vol = spm_read_vols(spm_vol(mask_c));    mask_vol(isnan(mask_vol)) = 0;
			else                 mask_vol = ones(size(L_vol));                 end;
		  if strcmp(C,'none')~=1;    C_vol = spm_read_vols(spm_vol(C));            C_vol(isnan(C_vol)) = 0;       end;		


		% ...still steady... (compute mask weighting factor to rule 
		% out any possible influence due to different masking volumes)
		  if strcmp(B,'none')~=1
			mwf = sum(sum(sum((L_vol>0.1).*(mask_vol>0.1))))/sum(sum(sum((R_vol>0.1).*(mask_vol>0.1))));

			% issue a warning and abort if mask is very asymmetrical
			  if mwf > 2 | mwf < 0.5
				uiwait(msgbox(['The mask you chose is VERY asymetrical (Vol [L] / Vol [R] = ' num2str(mwf) ') - are you REALLY sure you want to continue?'], 'Mask asymmetry warning', 'warn'));
				maw = spm_input('Continue with this mask?','+1','b',[' Yes| No'],[1 0],0);
				if maw == 0
					return;
				end;
			  end;
		  else
			mwf = 1;
		  end;


		% .. GO :)
		  if vw == 0	
			  if strcmp(B,'none')~=1
				  if strcmp(C,'none')~=1
				  	res_l = con_vol.*(mask_vol>0.1).*C_vol.*(L_vol>0.1);
				  	res_r = con_vol.*(mask_vol>0.1).*C_vol.*(R_vol>0.1);
				  else
				  	res_l = con_vol.*(mask_vol>0.1).*(L_vol>0.1);
				  	res_r = con_vol.*(mask_vol>0.1).*(R_vol>0.1);
				  end;
			  else
				  if strcmp(C,'none')~=1
				  	res_l = con_vol.*C_vol.*(L_vol>0.1);
				  	res_r = con_vol.*C_vol.*(R_vol>0.1);
				  else
				  	res_l = con_vol.*(L_vol>0.1);
				  	res_r = con_vol.*(R_vol>0.1);
				  end;
			  end;
		  else
			  if strcmp(B,'none')~=1
				  if strcmp(C,'none')~=1
				  	res_l = (con_vol./(wi_vol+eps)).*(mask_vol>0.1).*C_vol.*(L_vol>0.1);
				  	res_r = (con_vol./(wi_vol+eps)).*(mask_vol>0.1).*C_vol.*(R_vol>0.1);
				  else
				  	res_l = (con_vol./(wi_vol+eps)).*(mask_vol>0.1).*(L_vol>0.1);
				  	res_r = (con_vol./(wi_vol+eps)).*(mask_vol>0.1).*(R_vol>0.1);
				  end;
			  else
				  if strcmp(C,'none')~=1
				  	res_l = (con_vol./(wi_vol+eps)).*C_vol.*(L_vol>0.1);
				  	res_r = (con_vol./(wi_vol+eps)).*C_vol.*(R_vol>0.1);
				  else
				  	res_l = (con_vol./(wi_vol+eps)).*(L_vol>0.1);
			  		res_r = (con_vol./(wi_vol+eps)).*(R_vol>0.1);
				  end;
			  end;
		  end;


		% ===== now check for voxels and cluster size  =====
		% prepare and pass for labelling
		  [c_r,numr] = spm_bwlabel(res_r,18);
		  [c_l,numl] = spm_bwlabel(res_l,18);
		  c_r = sort(reshape(c_r,1,[]));
		  c_r(find(c_r==0)) = [];
		  c_l = sort(reshape(c_l,1,[]));
		  c_l(find(c_l==0)) = [];

		% get number of voxels decision is based on
		  nvoxr = size((c_r),2);
		  nvoxl = size((c_l),2);

		% warn if voxel number is below critical (set to 10 by default) and abort iterations if below minimum (set to 5 by default) 
		  if nvoxr < ncr & nvoxr > nabort
			fprintf(['\n' '\t' 'Warning: Number of voxels on the RIGHT is only ' num2str(nvoxr) ' !' '\n' '\n']);
		  elseif nvoxr < nabort
			fprintf(['\n' '\t' 'Warning: Number of voxels on the RIGHT (threshold = ' num2str(thr3) ') is below minimum required (' num2str(nabort) ') - aborting!' '\n' '\n']);
			abort = 1;
		  end;

		  if nvoxl < ncr & nvoxl > nabort
			fprintf(['\n' '\t' 'Warning: Number of voxels on the LEFT is only ' num2str(nvoxl) ' !' '\n' '\n']);
		  elseif nvoxl < nabort
			fprintf(['\n' '\t' 'Warning: Number of voxels on the LEFT (threshold = ' num2str(thr3) ') is below minimum required (' num2str(nabort) ') - aborting!' '\n' '\n']);
			abort = 1;
		  end;


		% only need to proceed if there are voxels in the first place
		  if abort == 0

			% ===== now check for minimum cluster size; set to 5 by default  =====
			    PP = 'Checking voxels and cluster size (L & R)';
			    spm('FigName', PP);

			% now check if at least one cluster on the left or right is above k
			  QR = 0;
			  for kk = 1:numr
      				ll = find(c_r == kk);
				if length(ll) >= k
					QR = 1;
				end;

				% only need one cluster, so if found, break out
				  if QR == 1; break;  end;
			  end;

			  QL = 0;
			  for kk = 1:numl
     				ll = find(c_l == kk);
				if length(ll) >= k
					QL = 1;
				end;

				% only need one cluster, so if found, break out
				  if QL == 1; break; end;
			  end;

			% generate warning if no cluster above k is found
			  if QR == 0
				fprintf(['\n' '  Warning: No cluster on the RIGHT is > ' num2str(k) ' voxels!' '\n']);
			  end;

			  if QL == 0
				fprintf(['\n' '  Warning: No cluster on the LEFT is > ' num2str(k) ' voxels!' '\n']);
			  end;


			% ===== Finally, calculate lateralization index  =====
			% as LI = (L-R)/(L+r)
			% NB:	 +1 is all LEFT	   -1 is all RIGHT
			% just to be extra sure, binarize again, also
			% avoid Divide by Zeros error message and
			% take into account mask weighting factor;
			  CL = sum(res_l(find(res_l.*(res_l>0))));
			  CR = sum(res_r(find(res_r.*(res_r>0))));

			  LI1 = (CL/mwf-CR)/((CL/mwf+CR)+eps);
		  end;


% ==========================================================================================================
%                                          	Output
% ==========================================================================================================

		% ===== Check output options  ===== 
		% if we want to generate reports both as a text file and
		% for the screen (out=2), do both; else (default), screen-only
		    PP = 'Generating output';
		    spm('FigName', PP);

		% ===== convert stuff for display =====
		  files = spm_str_manip(file_ns, ['t' 's']);
		  files_p = spm_str_manip(file_ns, ['h' 's']);
		  files_p = strrep(files_p, '\', '/');
		  if findstr(file_vol_ns.descrip,'contrast') ~= 0
			[l, f] = strtok(file_vol_ns.descrip,'contrast');
			files = [files ' (' f ')'];
		  end;

		  thrd = sprintf('%0.3g', thr3);
		  if strcmp(B, 'none') ~= 1
			masks = spm_str_manip(mask, ['t' 's']);
			masks = strrep(masks, '\', '/');
		  else
			masks = 'none';
		  end;

		% only proceed if no reason to abort
		  if abort == 0

			  if sm == 1;    smd = 'yes';   else    smd = 'no';    end; 
			  if vw == 1;    vwd = 'yes';   else    vwd = 'no';    end;
			  if strcmp(C,'none')~= 1
				cs = spm_str_manip(C, ['t' 's']);
				cs = strrep(cs, '\', '/');
			  else
				  cs = 'none';
			  end;
			  LI = sprintf('%0.3g', LI1);
			  nvoxrd = sprintf('%0g', nvoxr);
			  nvoxld = sprintf('%0g', nvoxl);
			  numld = sprintf('%0g', numl);
			  numrd = sprintf('%0g', numr);
			  wd = strrep(pwd, '\', '/');


			% ===== write out results so we have something to show =====
			  V = spm_vol(file);
			  V.fname = 'LI_input_r.img';
			  spm_write_vol(V,res_r);
			  V.fname = 'LI_input_l.img';
			  spm_write_vol(V,res_l);
			  V.fname = 'LI_input.img';
			  result = spm_read_vols(spm_vol(file));
			  result(isnan(result)) = 0;
			  spm_write_vol(V,result);


			% ===== now generate text and graphical output, depending on chosen output =====
			  for rep=1:out
			    if rep == 1
				% nicely show results: graphics first
	  			  if strcmp(B,'none')~=1
					  show = str2mat('LI_input.img', mask_c, 'LI_input_l.img', 'LI_input_r.img');
				  else
					  show = str2mat('LI_input.img', L, 'LI_input_l.img', 'LI_input_r.img');
				  end;
				  spm_check_registration(show);
		 
				% now text output; looks good on our screens, never sure about others...
				% only display applicable optional steps, but write everything to file
				  fprintf(['    ____________________________', '\n']);
				  fprintf('%35s\t%s\n\n','  The input image             ', (files));
				  fprintf('%35s\t%s\t\t%s\n\n','    - was thresholded at         ', (thrd), (meth));
				 	if strcmp(masks,'none') == 0
					  fprintf('%35s\t%s\n\n','    - was masked (incl.) using   ', (masks));
					end;
				 	if strcmp(cs,'none') == 0
					  fprintf('%35s\t%s\n\n','    - was masked (excl.) using   ', (cs));
					end;
       	 			  fprintf('%35s\t%s\n\n','    - was analyzed using         ', (cm));
				 	if strcmp(vwd,'no') == 0
             		 		  fprintf('%35s\t%s\n\n','    - applying variance weighting', (vwd));
					end;
				 	if strcmp(smd,'no') == 0
             		 		  fprintf('%35s\t%s\n\n','    - using data clustering      ', (smd));
					end;
				  fprintf('%35s\t%s\t%s\t%s\t%s\n\n','    - based on                   ', (nvoxld), ' voxels in ', (numld), ' clusters on the left');
				  fprintf('%35s\t%s\t%s\t%s\t%s\n\n','      and                        ', (nvoxrd), ' voxels in ', (numrd), ' clusters on the right');
				  fprintf('%35s\t%s\n','  The resulting LI is            ', (LI));
				  fprintf(['    ____________________________', '\n']);
			
				  if out == 1
					fprintf(['    - NB: screen-only output -' '\n']);
				  else
					fprintf(['    - Data was saved to ' outfile ' and LI_masking.ps in ' (wd) ' -' '\n']);
				  end;

			    else
    		           	% if file output was chosen, additionally write to tab-delimited text file (spreadsheet-friendly :)
				  new = exist([pwd filesep outfile],'file');
       			          fid = fopen(outfile,'At+');
				  if new == 0
				    fprintf(fid, ['\t' 'Input image' '\t' 'Inclusive mask' '\t' 'Exclusive mask' '\t' 'Threshold' '\t' 'LI' '\t' 'Method' '\t' 'VC/VV' '\t' 'Variance Weighting' '\t' 'Clustering' '\t' 'Source path' '\t' 'Voxels (right)' '\t' 'Voxels (left)' '\t' 'Clusters (right)' '\t' 'Clusters (left)' '\n']);
				  end;
				    fprintf(fid, ['\t' (files) '\t' (masks) '\t' (cs) '\t' (thrd) '\t' (LI) '\t' (meth) '\t' (cm) '\t' (vwd) '\t' (smd) '\t' (files_p) '\t' (nvoxrd) '\t' (nvoxld) '\t' (numrd) '\t' (numld) '\n']);
				  fclose(fid);

				% now save masking visualization to file; helpful for post-hoc checking of masking in larger collections
				  fg = spm_figure('Findwin','Graphics');
				  fnote = sprintf('%s%s%s',['Ctr: ' (files)],[';    Incl: ' (masks)],[';    Excl.: ' (cs)]);
				  set(0,'CurrentFigure',fg);
				  axes('Position',[0.005,0.005,0.1,0.1], 'Visible','off');
				  text(0,0,fnote,'FontSize',8,'interpreter','none');

				  if exist([pwd filesep 'LI_masking.ps'],'file') == 2
					  print(fg,'LI_masking.ps','-dpsc2', '-painters', '-append', '-noui');
				  else
					  print(fg,'LI_masking.ps','-dpsc2', '-painters', '-noui');
				  end;

			    end;
			end;
		  else
			fprintf(['\t' '  Calculation aborted due to lack of voxels in ' '\n\t\t' (files) '\n\t' '  after masking with' '\n\t\t' (masks) ' !' '\n']);
		  end;
	  end;
  end;

% ==========================================================================================================
%                                        	  Clean ups
% ==========================================================================================================


% ===== clean up files; also clear graphics if files are deleted  =====
  if script == 0
	RA = spm_input('Delete temporary files ?','+1','b',[' Yes| No'],[1 0],1);
  else
	RA = 1;
  end;

  if RA == 1
	fg = spm_figure('Findwin','Graphics');
	spm_figure('Clear',fg);
	delete LI_*.hdr
	delete LI_*.img
	delete LI_*.mat
	fprintf(['\n' '\n' '  Deleting Files...done' '\n' '\n']);
  else
	fprintf(['\n' '\n' '  Files were -not- deleted' '\n' '\n']);
  end;


% ===== say goodbye ===== 
  PP = 'Have a nice day  :)';
  spm('FigName', PP);


% re-enable warning
  warning on MATLAB:divideByZero


% ===== That's all folks =====
  return;